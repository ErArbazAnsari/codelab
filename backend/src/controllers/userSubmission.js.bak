const Problem = require("../models/problem")
const Submission = require("../models/submission")
const User = require("../models/user")
const { getLanguageById, submitBatch, submitToken } = require("../../utils/problemUtility")
const { updateUserStats } = require("./userStatsController")

const submitCode = async (req, res) => {
  try {
    const userId = req.result._id;
    const problemId = req.params.id;
    let { code, language } = req.body;

    // Validate input
    if (!userId || !code || !problemId || !language) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: code, language, or problem ID"
      });
    }

    // Normalize language name
    if (language === "cpp") language = "c++";
    
    // Fetch the problem
    const problem = await Problem.findById(problemId);
    if (!problem) {
      return res.status(404).json({
        success: false,
        error: "Problem not found"
      });
    }

    // Create submission record
    const submittedResult = await Submission.create({
      userId,
      problemId,
      code,
      language,
      status: "pending",
      testCasesTotal: problem.hiddenTestCases.length,
    });

    //    Judge0 code ko submit karna hai

    const languageId = getLanguageById(language)

    const submissions = problem.hiddenTestCases.map((testcase) => ({
      source_code: code,
      language_id: languageId,
      stdin: testcase.input,
      expected_output: testcase.output,
    }))

    const submitResult = await submitBatch(submissions)

    const resultToken = submitResult.map((value) => value.token)

    const testResult = await submitToken(resultToken)

    // submittedResult ko update karo
    let testCasesPassed = 0
    let runtime = 0
    let memory = 0
    let status = "accepted"
    let errorMessage = null

    for (const test of testResult) {
      if (test.status_id == 3) {
        testCasesPassed++
        runtime = runtime + Number.parseFloat(test.time)
        memory = Math.max(memory, test.memory)
      } else {
        if (test.status_id == 4) {
          status = "error"
          errorMessage = test.stderr
        } else {
          status = "wrong"
          errorMessage = test.stderr
        }
      }
    }

    // Store the result in Database in Submission
    submittedResult.status = status
    submittedResult.testCasesPassed = testCasesPassed
    submittedResult.errorMessage = errorMessage
    submittedResult.runtime = runtime
    submittedResult.memory = memory

    await submittedResult.save()

    // Update user stats
    await updateUserStats(userId, problemId, status === "accepted")

    // ProblemId ko insert karenge userSchema ke problemSolved mein if it is not persent there.

    // req.result == user Information

    if (status === "accepted" && !req.result.problemSolved.includes(problemId)) {
      req.result.problemSolved.push(problemId)
      await req.result.save()
    }

    const accepted = status == "accepted"
    res.status(201).json({
      accepted,
      totalTestCases: submittedResult.testCasesTotal,
      passedTestCases: testCasesPassed,
      runtime,
      memory,
    })
  } catch (err) {
    res.status(500).send("Internal Server Error " + err)
  }
}

const runCode = async (req, res) => {
  try {
    const userId = req.result._id;
    const problemId = req.params.id;
    let { code, language, customInput } = req.body;

    // Input validation
    if (!userId || !code || !problemId || !language) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: code, language, or problem ID"
      });
    }

    // Fetch the problem
    const problem = await Problem.findById(problemId);
    if (!problem) {
      return res.status(404).json({
        success: false,
        error: "Problem not found"
      });
    }

    // Normalize language name
    if (language === "cpp") language = "c++";

    // Get language ID
    const languageId = getLanguageById(language);
    if (!languageId) {
      return res.status(400).json({
        success: false,
        error: "Unsupported programming language"
      });
    }

    // Prepare test cases
    let submissions;
    if (customInput) {
      // If custom input is provided, use that
      submissions = [{
        source_code: code,
        language_id: languageId,
        stdin: customInput
      }];
    } else {
      // Use visible test cases
      if (!problem.visibleTestCases || problem.visibleTestCases.length === 0) {
        return res.status(400).json({
          success: false,
          error: "No test cases available for this problem"
        });
      }
      submissions = problem.visibleTestCases.map((testcase) => ({
        source_code: code,
        language_id: languageId,
        stdin: testcase.input,
        expected_output: testcase.output,
      }));
    }

    // Submit code to Judge0
    const submitResult = await submitBatch(submissions);
    if (!submitResult) {
      throw new Error("Failed to submit code to judge");
    }

    const resultToken = submitResult.map((value) => value.token);
    const testResult = await submitToken(resultToken);

    if (!testResult) {
      throw new Error("Failed to get test results");
    }

    // Process results
    let testCasesPassed = 0;
    let runtime = 0;
    let memory = 0;
    let results = [];

    testResult.forEach((result, index) => {
      const testCase = customInput ? { input: customInput } : problem.visibleTestCases[index];
      
      // Calculate metrics
      runtime = Math.max(runtime, parseFloat(result.time) || 0);
      memory = Math.max(memory, parseFloat(result.memory) || 0);
      
      const testCaseResult = {
        input: testCase.input,
        expectedOutput: testCase.output,
        actualOutput: result.stdout,
        status: result.status.description,
        passed: result.status_id === 3,
        time: result.time,
        memory: result.memory
      };

      if (result.status_id === 3) testCasesPassed++;
      results.push(testCaseResult);
    });

    res.json({
      success: true,
      results: results,
      summary: {
        totalTestCases: testResult.length,
        testCasesPassed,
        runtime: runtime.toFixed(2),
        memory: Math.round(memory),
        status: testCasesPassed === testResult.length ? "Accepted" : "Failed"
      }
    });
    
  } catch (err) {
    console.error("Error running code:", err);
    res.status(500).json({
      success: false,
      error: err.message || "Internal server error while running code"
    });
  }
};
        memory = Math.max(memory, test.memory)
      } else {
        if (test.status_id == 4) {
          status = false
          errorMessage = test.stderr
        } else {
          status = false
          errorMessage = test.stderr
        }
      }
    }

    res.status(201).json({
      success: status,
      testCases: testResult,
      runtime,
      memory,
    })
  } catch (err) {
    res.status(500).send("Internal Server Error " + err)
  }
}

module.exports = { submitCode, runCode }

//     language_id: 54,
//     stdin: '2 3',
//     expected_output: '5',
//     stdout: '5',
//     status_id: 3,
//     created_at: '2025-05-12T16:47:37.239Z',
//     finished_at: '2025-05-12T16:47:37.695Z',
//     time: '0.002',
//     memory: 904,
//     stderr: null,
//     token: '611405fa-4f31-44a6-99c8-6f407bc14e73',

// User.findByIdUpdate({
// })

//const user =  User.findById(id)
// user.firstName = "Mohit";
// await user.save();
